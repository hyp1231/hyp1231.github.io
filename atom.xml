<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yupeng&#39;s Blog</title>
  
  <subtitle>Coding and Enjoy Life!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-08T11:01:51.610Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yupeng Hou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「CodeM2018复赛」 软件包管理器 - 二分答案 + 拓扑排序</title>
    <link href="http://yoursite.com/2018/07/08/20180708-codem/"/>
    <id>http://yoursite.com/2018/07/08/20180708-codem/</id>
    <published>2018-07-08T07:50:26.000Z</published>
    <updated>2018-07-08T11:01:51.610Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$n$ 个点的图，依次添加给出的 $m$ 条有向边。</p><p>每次添加后，如果图中有环，输出 $0$；否则输出 $1$。</p><p>$n \le 1e5, m \le 2e6$</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第一行两个正整数 $n$ 和 $m$。</p><p>之后 $m$ 行，每行两个正整数 $(u’, v’)$ 表示加密后的边，保证 $u’ \not = v’$</p><p>记上一个回答为 $ans$，实际的边为 $(u, v)$ </p><p>则有 $\begin{cases}u’ =  (u + ans) \pmod n + 1\\ v’ = (v + ans) \pmod n  + 1\end{cases}$</p><p>最开始的 $ans$ 为 $0$</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>暂无</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>如果加了某条边后，图中出现环，那么这条边及以后的 $ans$ 应全为 $0$。</p><p>因此题意即为找到 $ans$ 序列的 $1$ 和 $0$ 的分界线。</p><p>考虑二分答案，每次判断 $1 \to mid$ 的边构成的图是否为 DAG。</p><p>如果对 $1 \to mid$ 的边建成的图可以做拓扑排序，则是 DAG；否则说明必有环。</p><p>由于拓扑排序时间复杂度 $O(n)$，总时间复杂度 $O(n\log{m})$。</p><div class="note warning"><p>Hint: 我们可以在读入数据的时候预处理出解密后的 $(u, v)$：</p><p>​    如果上一个 $ans$ 是 $0$，则 $u = (u’-1+n) \% n$ ；</p><p>​    否则，$u = (u’ - 2 + n) \% n$。$v$ 同理。</p></div><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    E(<span class="keyword">int</span> u = <span class="number">0</span>, <span class="keyword">int</span> v = <span class="number">0</span>) : u(u), v(v) &#123;&#125;</span><br><span class="line">&#125; pre_0[N &lt;&lt; <span class="number">1</span>], pre_1[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 如果上一个 ans 是 0，实际的边为 pre_0[i]；否则是 pre_1[i]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> degree[N];      <span class="comment">// 节点度数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> e_id, head[N];  <span class="comment">// e_id 记录边数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, next;</span><br><span class="line">    Edge(<span class="keyword">int</span> u = <span class="number">0</span>, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> next = <span class="number">0</span>) :u(u), v(v), next(next) &#123;&#125;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    e[++e_id].v = b;</span><br><span class="line">    e[e_id].u = a;</span><br><span class="line">    e[e_id].next = head[a];</span><br><span class="line">    head[a] = e_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    e_id = <span class="number">0</span>;</span><br><span class="line">    addedge(pre_0[<span class="number">0</span>].u, pre_0[<span class="number">0</span>].v);    <span class="comment">// 初始 ans 为 0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= id; ++i) &#123;      <span class="comment">// 假设前 id 条边构成 DAG</span></span><br><span class="line">        <span class="keyword">int</span> u = pre_1[i].u, v = pre_1[i].v;</span><br><span class="line">        addedge(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topo</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    build(id);  <span class="comment">// 建图</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(degree, <span class="number">0</span>, <span class="keyword">sizeof</span>(degree));</span><br><span class="line">    ++degree[pre_0[<span class="number">0</span>].v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= id; ++i)</span><br><span class="line">        ++degree[pre_1[i].v];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (degree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            que.push(i);</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span> (vis[v])<span class="keyword">continue</span>;</span><br><span class="line">            --degree[v];</span><br><span class="line">            <span class="keyword">if</span> (degree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                que.push(v);</span><br><span class="line">                vis[v] = <span class="literal">true</span>;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt == n;</span><br><span class="line">&#125;   <span class="comment">// 如果拓扑有序，返回 true，O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (topo(mid)) <span class="keyword">return</span> solve(mid, r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> solve(l, mid - <span class="number">1</span>);</span><br><span class="line">&#125;   <span class="comment">// 二分，返回最大的可以构成 DAG 的边数，即 [1, id] 可以构成 DAG，但 [1, id + 1] 不可以</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        --u; --v;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">0</span>) u = n;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="number">0</span>) v = n;  <span class="comment">// 取模</span></span><br><span class="line">        pre_0[i].u = u;</span><br><span class="line">        pre_0[i].v = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = pre_0[i].u - <span class="number">1</span>, v = pre_0[i].v - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">0</span>) u = n;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="number">0</span>) v = n;</span><br><span class="line">        pre_1[i].u = u;</span><br><span class="line">        pre_1[i].v = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = solve(<span class="number">0</span>, m - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (i &lt;= k));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;$n$ 个点的图，依次添加给出的 $m$ 条有向边。&lt;/p&gt;
&lt;p&gt;每次添加后，如果图中有环，输出 $0$；否则输出 $1$。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="题解" scheme="http://yoursite.com/categories/ACM/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="二分答案" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
      <category term="拓扑排序" scheme="http://yoursite.com/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/06/20/20180620-HelloWorld/"/>
    <id>http://yoursite.com/2018/06/20/20180620-HelloWorld/</id>
    <published>2018-06-19T16:49:00.210Z</published>
    <updated>2018-07-08T07:56:10.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Welcome-欢迎"><a href="#Welcome-欢迎" class="headerlink" title="Welcome! 欢迎"></a>Welcome! 欢迎</h2><p>It’s so nice for you to visit here!<br>欢迎来到我的博客！</p><p>Look around to find something interesting.<br>四处逛逛来发现一些有趣的东西吧～</p><h2 id="This-Blog-and-Me-博客和我"><a href="#This-Blog-and-Me-博客和我" class="headerlink" title="This Blog and Me 博客和我"></a>This Blog and Me 博客和我</h2><h3 id="为什么开设这个博客"><a href="#为什么开设这个博客" class="headerlink" title="为什么开设这个博客"></a>为什么开设这个博客</h3><p>一是对学习生活的记录<br>一篇用心的学习笔记想来会迫使我系统地整理新学到的知识，也会督促我完成学习 plan。</p><p>二是分享我的经验<br>哪怕能帮助你节省一点点时间，能助力你一个新的灵感，都会使我非常开心的呐！</p><h3 id="我"><a href="#我" class="headerlink" title="我"></a>我</h3><p>如果对我感兴趣，请到<a href="https://hyp1231.github.io/about/" target="_blank" rel="noopener">这里</a>来 ～( ´▽｀)～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Welcome-欢迎&quot;&gt;&lt;a href=&quot;#Welcome-欢迎&quot; class=&quot;headerlink&quot; title=&quot;Welcome! 欢迎&quot;&gt;&lt;/a&gt;Welcome! 欢迎&lt;/h2&gt;&lt;p&gt;It’s so nice for you to visit here!&lt;
      
    
    </summary>
    
      <category term="日常" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
</feed>
