<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hyp1231&#39;s Blog</title>
  
  <subtitle>Coding and Enjoy Life!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-17T06:18:06.105Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>hyp1231</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「Codeforces 1006F」Xor-Paths - 双向bfs</title>
    <link href="http://yoursite.com/2018/07/17/20180717-cf1006f/"/>
    <id>http://yoursite.com/2018/07/17/20180717-cf1006f/</id>
    <published>2018-07-17T05:46:33.000Z</published>
    <updated>2018-07-17T06:18:06.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $n \times m$ 的矩阵，以及一个整数 $k$。<br>定义路径为，从 $(1,1)$ 出发，只能向右 / 下方走，到达 $(n, m)$ 的行走方案。<br>定义路径的权重为，路径经过的整数的 $xor$ 之和。<br>求权重为 $k$ 的路径的条数。</p><a id="more"></a><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://codeforces.com/problemset/problem/1006/F" target="_blank" rel="noopener">Codeforces 1006F</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>定义从路径一端到 $(x,y)$ 的某条路径上的整数的 $xor$ 之和为 $(x,y)$ 处的<strong>状态</strong>。</p><p>由于 $n$ 和 $m$ 的范围均为 $20$ 之内，考虑暴力搜索。对于每个位置，之后都有两种状态转移（向下 / 向右）。因此我们将矩阵按照 $m + n$ 的值进行分层，如果从起点开始 $bfs$，易知每次状态转移使层数加一，每一层的状态数不超过上一层的二倍，故直接 $bfs$ 的状态数不超过 $2 ^ {m+ n}$ ，但这个量级是我们不能接受的。</p><p>而考虑起点和终点的值都是唯一且确定的，我们可以从起点和终点同时采用 $bfs$。因此我们规定 $\frac{m + n}{2}$ 为中心层，两个 $bfs$ 一到中心层则停止搜索，这样在中心层，如果有重合的状态则说明有合法路径。</p><p>为了记录合法路径的数目，我们需要记录某一个 $bfs$ （这里不妨设为从起点出发的）到达状态 $val$ 的路径数。在实现上，我们使用 $STL$ 库中的 $map$，形成状态到路径数的映射。这样先实现从起点出发的 $bfs$，得到中间层每个位置各个状态的路径数；再做另一个 $bfs$，对于每个到中间层的状态，把第一个 $bfs$ 中计算出的该状态对应的路径数加到总的 $ans$ 中。</p><p>这样搜索到中间层的状态数不超过 $2^{\frac{m+n}{2}}$，$map$ 的复杂度 $O(\log {2^{\frac{m+n}{2}}}) = O(\frac{m+ n}{2}\log 2) = O(\frac{m + n}{2})$，总复杂度 $O(\frac{m+n}{2} \cdot 2^{\frac{m+n}{2}})$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    LL val;</span><br><span class="line">    State(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>, LL val = <span class="number">0</span>) : x(x), y(y), val(val) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, mid;</span><br><span class="line">LL a[N][N], k;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录中间层 状态-&gt;路径数 的映射</span></span><br><span class="line"><span class="comment">// 由于 x + y = (n + m) / 2，我们确定了 x 即可确定 y</span></span><br><span class="line"><span class="comment">// 因此 res[x][st] 代表中间层横坐标为 x 的点，状态为 st 的路径数目</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;LL, <span class="keyword">int</span>&gt; res[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    mid = (n + m - <span class="number">2</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;State&gt; que1, que2;</span><br><span class="line">    que1.push(State(<span class="number">0</span>, <span class="number">0</span>, a[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">while</span> (!que1.empty()) &#123;</span><br><span class="line">        State tmp = que1.front(); que1.pop();</span><br><span class="line">        <span class="keyword">int</span> x = tmp.x, y = tmp.y;</span><br><span class="line">        LL val = tmp.val;</span><br><span class="line">        <span class="keyword">if</span> (x + y == mid) &#123; <span class="comment">// 到达中心线</span></span><br><span class="line">            <span class="keyword">if</span> (res[x].count(val)) &#123;</span><br><span class="line">                ++res[x][val];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[x][val] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + <span class="number">1</span> != n) que1.push(State(x + <span class="number">1</span>, y, val ^ a[x + <span class="number">1</span>][y]));</span><br><span class="line">            <span class="keyword">if</span> (y + <span class="number">1</span> != m) que1.push(State(x, y + <span class="number">1</span>, val ^ a[x][y + <span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    que2.push(State(n - <span class="number">1</span>, m - <span class="number">1</span>, k));</span><br><span class="line">    <span class="keyword">while</span> (!que2.empty()) &#123;</span><br><span class="line">        State tmp = que2.front(); que2.pop();</span><br><span class="line">        <span class="keyword">int</span> x = tmp.x, y = tmp.y;</span><br><span class="line">        LL val = tmp.val;</span><br><span class="line">        <span class="keyword">if</span> (x + y == mid) &#123;</span><br><span class="line">            ans += res[x][val];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (x - <span class="number">1</span> &gt;= <span class="number">0</span>) que2.push(State(x - <span class="number">1</span>, y, val ^ a[x][y]));</span><br><span class="line">            <span class="keyword">if</span> (y - <span class="number">1</span> &gt;= <span class="number">0</span>) que2.push(State(x, y - <span class="number">1</span>, val ^ a[x][y]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给定 $n \times m$ 的矩阵，以及一个整数 $k$。&lt;br&gt;定义路径为，从 $(1,1)$ 出发，只能向右 / 下方走，到达 $(n, m)$ 的行走方案。&lt;br&gt;定义路径的权重为，路径经过的整数的 $xor$ 之和。&lt;br&gt;求权重为 $k$ 的路径的条数。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="题解" scheme="http://yoursite.com/categories/ACM/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="双向bfs" scheme="http://yoursite.com/tags/%E5%8F%8C%E5%90%91bfs/"/>
    
  </entry>
  
  <entry>
    <title>「Codeforces 1009E」Intercity Travelling - 组合数学</title>
    <link href="http://yoursite.com/2018/07/16/20180716-cf1009e/"/>
    <id>http://yoursite.com/2018/07/16/20180716-cf1009e/</id>
    <published>2018-07-16T00:55:28.000Z</published>
    <updated>2018-07-16T02:46:12.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>Leha 想开车去 Saratov，这段旅途看作 $0$ 到 $n$ 的一维直线。<br>如果 Leha 从起点出发或者从休息点出发，连续驾驶 $k$ 千米，则需要消耗的体能为 $a_1 + a_2 + \ldots + a_k$。<br>每个整点 $t, (1 \le t &lt; n)$ 都可能拥有一个休息点，每个休息点存在或不存在的概率相等。<br>记 Leha 整个旅程消耗的体能的期望为 $p$，求 $p\cdot 2^{n - 1}$。</p><a id="more"></a><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://codeforces.com/problemset/problem/1009/E" target="_blank" rel="noopener">Codeforces 1009E</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>旅途中共有 $n - 1$ 个整点，故有 $2^{n - 1}$ 种可能的休息点摆放方案，故 $p\cdot 2^{n - 1}$ 为所有可能情况消耗体能之和。</p><p>我们先考虑总和中的 $a_1$ 的数量。由于每个休息点之后紧邻的 $1km$ 路程一定消耗 $a_1$ 的体能，因此某种摆放方案中 $a_1$ 的数量等于休息点个数加一（起点之后一定消耗 $a_1$）。考虑有 $j$ 个休息点时，有 $C_{n-1}^{j}$ 种摆放方案，故 $j$ 个休息点的情况下 $a_1$ 的数量和为 $(j + 1)C_{n-1}^j$。</p><p>记 $N_1$ 为所有摆放方案下 $a_1$ 的数量和，则有<br>$$<br>N_1 = \sum \limits_{i = 1}^{n} i \cdot C_{n-1}^{i-1}<br>$$<br>即 $N_1 = 1 \cdot C_{n-1}^{0} + 2 \cdot C_{n - 1}^{1} + \ldots + n \cdot C_{n-1}^{n-1}$</p><p>又由于 $C_{n -1}^{i} = C_{n - 1}^{n-1 -i}$，有 $N_1 = 1 \cdot C_{n-1}^{n-1} + 2 \cdot C_{n - 1}^{n-2} + \ldots + n \cdot C_{n-1}^{0}$</p><p>两式加和，有 $2 N_1 = (n + 1)\sum\limits_{i = 1}^{n}C_{n-1}^{i-1} = (n+1)\cdot 2^{n-1}$，即 $N_1 = (n + 1) \cdot 2^{n - 2}$</p><p>同理，有 $N_i = (n + 2 - i)\cdot 2^{n-1 - i}$，则<br>$$<br>p\cdot 2^{n - 1} = \sum\limits_{i=1}^{n} N_ia_i = \sum\limits_{i = 1} ^n (n + 2 - i) \cdot 2 ^{n - 1 - i} \cdot a_i<br>$$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::iostream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">LL a[N], p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>; p[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">    LL m = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;   <span class="comment">// 预处理系数，即 Ni</span></span><br><span class="line">        m = (m &lt;&lt; <span class="number">1</span>) % mod;         <span class="comment">// 2^(i - 1)</span></span><br><span class="line">        p[i] = (m * (i + <span class="number">2</span>)) % mod; <span class="comment">// (i + 2) * 2^(i - 1)</span></span><br><span class="line">    &#125;</span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        sum = (sum + p[n - i - <span class="number">1</span>] * a[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;Leha 想开车去 Saratov，这段旅途看作 $0$ 到 $n$ 的一维直线。&lt;br&gt;如果 Leha 从起点出发或者从休息点出发，连续驾驶 $k$ 千米，则需要消耗的体能为 $a_1 + a_2 + \ldots + a_k$。&lt;br&gt;每个整点 $t, (1 \le t &amp;lt; n)$ 都可能拥有一个休息点，每个休息点存在或不存在的概率相等。&lt;br&gt;记 Leha 整个旅程消耗的体能的期望为 $p$，求 $p\cdot 2^{n - 1}$。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="题解" scheme="http://yoursite.com/categories/ACM/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="组合数学" scheme="http://yoursite.com/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>「HDU 5677」 ztr loves substring - Manacher + 多重背包</title>
    <link href="http://yoursite.com/2018/07/10/20180710-hdu5677/"/>
    <id>http://yoursite.com/2018/07/10/20180710-hdu5677/</id>
    <published>2018-07-10T09:55:55.000Z</published>
    <updated>2018-07-16T00:56:47.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出 $N$ 个字符串，所有字符串的连续回文子串构成一个多重集合 $S$<br>求 $S$ 中是否存在恰好 $K$ 个串，使它们的长度之和为 $L$</p><a id="more"></a><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5677" target="_blank" rel="noopener">HDU5677 ztr loves substring</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>只与每个串的长度有关，故应先预处理出每个长度的回文串的数量。</p><p>使用 Manacher 算法计算出以串的各个位置为中心的最大回文串长度。若以 $s_i$ 为中心的最大回文串的长度为 $l$（不妨假设它为偶数），考虑逐步去掉两侧字符就可以造出更多回文子串。因此长度为 $2,4,\ldots, l$ 的子串的计数器分别加一（若 $l$ 为奇数，同理）。这样我们就得到了每个长度的串的数量，</p><p>考虑选出 $K​$ 个串使它们长度之和为 $L​$。即选出 $K​$ 个物品，填满容量为 $L​$ 的背包，每种物品的个数已知，是多重背包问题。设计 $dp[i][j]​$ 表示当前已经选了 $i​$ 个串，放在容量为 $j​$ 的背包中的最大容量。记放入新串后数量为 $num​$，当前背包容量为 $p​$，新增串个数为 $mul​$，新增子串长 $i​$，则状态转移方程为:<br>$dp[num][p] = MAX(dp[num][p], dp[num - mul][p - mul \cdot i] + mul\cdot i)​$</p><div class="note warning"><p>Hint 1: 转移要求在 $num = mul$（第一次添加串）或 $dp[num-mul][p - mul\cdot i]$ 不为 $0$ 时才转移（说明存在上一个状态）。<br>Hint 2: 使用二进制优化加速多重背包。</p></div><p>记长度为 $i$ 的回文子串的数量为 $W_i$。读入和 $N$ 次 Manacher 是 $O(NL)$ 的，多重背包是 $O\left((\sum \limits_{i = 1}^L\log{W_i})KL\right)$。总时间复杂度 $O\left((\sum \limits_{i = 1}^L\log{W_i})KL + NL\right)$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">128</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> mid_c = <span class="string">'$'</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> side_c = <span class="string">'@'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, l;</span><br><span class="line"><span class="keyword">char</span> s[N][N];</span><br><span class="line"><span class="keyword">char</span> s2[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> len, r[N][N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">char</span> s1[])</span> </span>&#123;</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    s2[len++] = side_c;</span><br><span class="line">    s2[len++] = mid_c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        s2[len++] = s1[i];</span><br><span class="line">        s2[len++] = mid_c;</span><br><span class="line">    &#125;</span><br><span class="line">    s2[len + <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manacher</span><span class="params">(<span class="keyword">char</span> s1[], <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    prepare(s1);</span><br><span class="line">    <span class="built_in">memset</span>(r[id], <span class="number">0</span>, <span class="keyword">sizeof</span>(r[id]));</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>, p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; i)x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> x = <span class="built_in">std</span>::min(p - i, r[id][<span class="number">2</span> * mid - i]);</span><br><span class="line">        <span class="keyword">while</span> (s2[i - x] == s2[i + x]) ++x;</span><br><span class="line">        <span class="keyword">if</span> (i + x &gt; p) &#123;</span><br><span class="line">            p = i + x;</span><br><span class="line">            mid = i;</span><br><span class="line">        &#125;</span><br><span class="line">        r[id][i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[N], dp[N][N];</span><br><span class="line"><span class="comment">// dp[i][j] 代表 i 个子串拼接成的串的最大长度（不超过 j）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;k, &amp;l);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            Manacher(s[i], i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = r[i][j] - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (tmp &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">while</span> (tmp &gt; <span class="number">0</span>) &#123;           <span class="comment">// 最长子串逐步去掉侧边字母也是子串</span></span><br><span class="line">                    ++cnt[tmp];</span><br><span class="line">                    tmp -= <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= l; ++i) &#123;      <span class="comment">// 枚举子串长度</span></span><br><span class="line">            <span class="keyword">int</span> sum = cnt[i];               <span class="comment">// 长度为 i 的子串数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; sum; j &lt;&lt;= <span class="number">1</span>) &#123; <span class="comment">// 二进制优化</span></span><br><span class="line">                <span class="keyword">int</span> mul = <span class="built_in">std</span>::min(sum, j);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> p = l; p &gt;= mul * i; --p)      <span class="comment">// 枚举长度</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> num = mul; num &lt;= k; ++num)<span class="comment">// 枚举已选字符串个数</span></span><br><span class="line">                        <span class="keyword">if</span> (num == mul || dp[num - mul][p - mul * i] &gt; <span class="number">0</span>)</span><br><span class="line">                            <span class="comment">// 如果本串是第一次被选，或存在选了 p - mul * i 个串的方案</span></span><br><span class="line">                            dp[num][p] = <span class="built_in">std</span>::max(dp[num][p], </span><br><span class="line">                                                  dp[num - mul][p - mul * i] + mul * i);</span><br><span class="line">                sum -= mul;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, (dp[k][l] == l ? <span class="string">"True"</span> : <span class="string">"False"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给出 $N$ 个字符串，所有字符串的连续回文子串构成一个多重集合 $S$&lt;br&gt;求 $S$ 中是否存在恰好 $K$ 个串，使它们的长度之和为 $L$&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="题解" scheme="http://yoursite.com/categories/ACM/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Manacher" scheme="http://yoursite.com/tags/Manacher/"/>
    
      <category term="多重背包" scheme="http://yoursite.com/tags/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>「CodeM2018复赛」 软件包管理器 - 二分答案 + 拓扑排序</title>
    <link href="http://yoursite.com/2018/07/08/20180708-codem/"/>
    <id>http://yoursite.com/2018/07/08/20180708-codem/</id>
    <published>2018-07-08T07:50:26.000Z</published>
    <updated>2018-07-11T00:55:26.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$n$ 个点的图，依次添加给出的 $m$ 条有向边。<br>每次添加后，如果图中有环，输出 $0$；否则输出 $1$。<br>$n \le 1e5, m \le 2e6$</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第一行两个正整数 $n$ 和 $m$。<br>之后 $m$ 行，每行两个正整数 $(u’, v’)$ 表示加密后的边，保证 $u’ \not = v’$</p><p>记上一个回答为 $ans$，实际的边为 $(u, v)$<br>则有 $\begin{cases}u’ =  (u + ans) \pmod n + 1\\ v’ = (v + ans) \pmod n  + 1\end{cases}$</p><p>最开始的 $ans$ 为 $0$</p><a id="more"></a><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.nowcoder.com/acm/contest/152/B" target="_blank" rel="noopener">CodeM2018复赛 软件包管理器</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>如果加了某条边后，图中出现环，那么这条边及以后的 $ans$ 应全为 $0$。<br>因此题意即为找到 $ans$ 序列的 $1$ 和 $0$ 的分界线。</p><p>考虑二分答案，每次判断 $1 \to mid$ 的边构成的图是否为 DAG。<br>如果对 $1 \to mid$ 的边建成的图可以做拓扑排序，则是 DAG；否则说明必有环。</p><p>由于拓扑排序时间复杂度 $O(n)$，总时间复杂度 $O(n\log{m})$。</p><div class="note warning"><p>Hint: 我们可以在读入数据的时候预处理出解密后的 $(u, v)$：<br>​    如果上一个 $ans$ 是 $0$，则 $u = (u’-1+n) \% n$ ；<br>​    否则，$u = (u’ - 2 + n) \% n$。$v$ 同理。</p></div><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    E(<span class="keyword">int</span> u = <span class="number">0</span>, <span class="keyword">int</span> v = <span class="number">0</span>) : u(u), v(v) &#123;&#125;</span><br><span class="line">&#125; pre_0[N &lt;&lt; <span class="number">1</span>], pre_1[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 如果上一个 ans 是 0，实际的边为 pre_0[i]；否则是 pre_1[i]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> degree[N];      <span class="comment">// 节点度数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> e_id, head[N];  <span class="comment">// e_id 记录边数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, next;</span><br><span class="line">    Edge(<span class="keyword">int</span> u = <span class="number">0</span>, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> next = <span class="number">0</span>) :u(u), v(v), next(next) &#123;&#125;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    e[++e_id].v = b;</span><br><span class="line">    e[e_id].u = a;</span><br><span class="line">    e[e_id].next = head[a];</span><br><span class="line">    head[a] = e_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    e_id = <span class="number">0</span>;</span><br><span class="line">    addedge(pre_0[<span class="number">0</span>].u, pre_0[<span class="number">0</span>].v);    <span class="comment">// 初始 ans 为 0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= id; ++i) &#123;      <span class="comment">// 假设前 id 条边构成 DAG</span></span><br><span class="line">        <span class="keyword">int</span> u = pre_1[i].u, v = pre_1[i].v;</span><br><span class="line">        addedge(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topo</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    build(id);  <span class="comment">// 建图</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(degree, <span class="number">0</span>, <span class="keyword">sizeof</span>(degree));</span><br><span class="line">    ++degree[pre_0[<span class="number">0</span>].v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= id; ++i)</span><br><span class="line">        ++degree[pre_1[i].v];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (degree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            que.push(i);</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span> (vis[v])<span class="keyword">continue</span>;</span><br><span class="line">            --degree[v];</span><br><span class="line">            <span class="keyword">if</span> (degree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                que.push(v);</span><br><span class="line">                vis[v] = <span class="literal">true</span>;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt == n;</span><br><span class="line">&#125;   <span class="comment">// 如果拓扑有序，返回 true，O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (topo(mid)) <span class="keyword">return</span> solve(mid, r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> solve(l, mid - <span class="number">1</span>);</span><br><span class="line">&#125;   <span class="comment">// 二分，返回最大的可以构成 DAG 的边数，即 [1, id] 可以构成 DAG，但 [1, id + 1] 不可以</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        --u; --v;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">0</span>) u = n;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="number">0</span>) v = n;  <span class="comment">// 取模</span></span><br><span class="line">        pre_0[i].u = u;</span><br><span class="line">        pre_0[i].v = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = pre_0[i].u - <span class="number">1</span>, v = pre_0[i].v - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">0</span>) u = n;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="number">0</span>) v = n;</span><br><span class="line">        pre_1[i].u = u;</span><br><span class="line">        pre_1[i].v = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = solve(<span class="number">0</span>, m - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (i &lt;= k));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;$n$ 个点的图，依次添加给出的 $m$ 条有向边。&lt;br&gt;每次添加后，如果图中有环，输出 $0$；否则输出 $1$。&lt;br&gt;$n \le 1e5, m \le 2e6$&lt;/p&gt;
&lt;h3 id=&quot;输入&quot;&gt;&lt;a href=&quot;#输入&quot; class=&quot;headerlink&quot; title=&quot;输入&quot;&gt;&lt;/a&gt;输入&lt;/h3&gt;&lt;p&gt;第一行两个正整数 $n$ 和 $m$。&lt;br&gt;之后 $m$ 行，每行两个正整数 $(u’, v’)$ 表示加密后的边，保证 $u’ \not = v’$&lt;/p&gt;
&lt;p&gt;记上一个回答为 $ans$，实际的边为 $(u, v)$&lt;br&gt;则有 $\begin{cases}u’ =  (u + ans) \pmod n + 1\\ v’ = (v + ans) \pmod n  + 1\end{cases}$&lt;/p&gt;
&lt;p&gt;最开始的 $ans$ 为 $0$&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="题解" scheme="http://yoursite.com/categories/ACM/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="二分答案" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
      <category term="拓扑排序" scheme="http://yoursite.com/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/06/20/20180620-HelloWorld/"/>
    <id>http://yoursite.com/2018/06/20/20180620-HelloWorld/</id>
    <published>2018-06-19T16:49:00.210Z</published>
    <updated>2018-07-10T11:00:19.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Welcome-欢迎"><a href="#Welcome-欢迎" class="headerlink" title="Welcome! 欢迎"></a>Welcome! 欢迎</h2><p>It’s so nice for you to visit here!<br>欢迎来到我的博客！</p><p>Look around to find something interesting.<br>四处逛逛来发现一些有趣的东西吧～</p><a id="more"></a><h2 id="This-Blog-and-Me-博客和我"><a href="#This-Blog-and-Me-博客和我" class="headerlink" title="This Blog and Me 博客和我"></a>This Blog and Me 博客和我</h2><h3 id="为什么开设这个博客"><a href="#为什么开设这个博客" class="headerlink" title="为什么开设这个博客"></a>为什么开设这个博客</h3><p>一是对学习生活的记录<br>一篇用心的学习笔记想来会迫使我系统地整理新学到的知识，也会督促我完成学习 plan。</p><p>二是分享我的经验<br>哪怕能帮助你节省一点点时间，能助力你一个新的灵感，都会使我非常开心的呐！</p><h3 id="我"><a href="#我" class="headerlink" title="我"></a>我</h3><p>如果对我感兴趣，请到<a href="https://hyp1231.github.io/about/" target="_blank" rel="noopener">这里</a>来 ～( ´▽｀)～</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Welcome-欢迎&quot;&gt;&lt;a href=&quot;#Welcome-欢迎&quot; class=&quot;headerlink&quot; title=&quot;Welcome! 欢迎&quot;&gt;&lt;/a&gt;Welcome! 欢迎&lt;/h2&gt;&lt;p&gt;It’s so nice for you to visit here!&lt;br&gt;欢迎来到我的博客！&lt;/p&gt;
&lt;p&gt;Look around to find something interesting.&lt;br&gt;四处逛逛来发现一些有趣的东西吧～&lt;/p&gt;
    
    </summary>
    
      <category term="日常" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
</feed>
