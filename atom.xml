<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hyp1231&#39;s Blog</title>
  
  <subtitle>Coding and Enjoy Life!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-28T09:16:41.490Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>hyp1231</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「Codeforces 1010D」Mars rover - dfs</title>
    <link href="http://yoursite.com/2018/07/28/20180728-cf1010d/"/>
    <id>http://yoursite.com/2018/07/28/20180728-cf1010d/</id>
    <published>2018-07-28T09:11:45.000Z</published>
    <updated>2018-07-28T09:16:41.490Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出一个以 $1$ 为根的有 $n$ 个节点的树，树的每个节点表示一个输入，或者一个逻辑关系。每个逻辑关系根据儿子节点的值，套入逻辑关系式，计算出当前节点的值。<br>现在让你求出，只改变任一个输入节点的值，根节点的取值。</p><a id="more"></a><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://codeforces.com/problemset/problem/1010/D" target="_blank" rel="noopener">Codeforces 1010D</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先我们可以规定一个结构体 $State$，定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">4</span>];      <span class="comment">// 代表逻辑关系（或输入）的字符串</span></span><br><span class="line">    <span class="keyword">int</span> next[<span class="number">2</span>];    <span class="comment">// 儿子节点标号</span></span><br><span class="line">    State() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">        next[<span class="number">0</span>] = next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当逻辑关系为 $AND, OR, XOR$ 时，<code>next[0]</code> 代表左儿子，<code>next[1]</code> 代表右儿子。<br>当逻辑关系为 $NOT$ 时，<code>next[0]</code> 代表儿子。<br>当表示输入 $IN$ 时，<code>next[0]</code> 代表输入的值（$0$ 或 $1$）。</p><p>我们可以一次 $dfs$ 求出每个节点的值，把它们记录在 <code>ori[N]</code> 数组中。</p><p>下面考虑怎么计算改变单一输入后根节点的值。</p><p>当一个输入改变时，它可以导致一系列节点的取值发生改变。而我们可以从根节点逆推，<strong>假设根节点的值改变了</strong>，考虑需要的条件。<br>先只考虑某个单一节点 $u$，<strong>假设 $u$ 的值改变了</strong>，分下面几种情况讨论：</p><ol><li><p>$u$ 是 $AND$<br>如果节点 $u$ 原来的取值是 $1$，说明两个儿子节点都是 $1$。根据假设，节点 $u$ 的值改变了，那么势必是因为两个儿子之一的值改变了。因此递归搜索两个儿子。（假设某个儿子的值改变了）<br>如果节点 $u$ 原来的取值是 $0$，那么说明两个儿子节点至少有一个是 $0$。根据假设，节点 $u$ 的值改变了，如果两个儿子节点都是 $0$，这个搜索分支结束（因为只改变一个输入无法使两个儿子节点的值全部改变）；否则只有一个儿子节点是 $0$，递归搜索原来取值为 $0$ 的那个儿子。</p></li><li><p>$u$ 是 $OR$<br>和第一种情况同理，只需要根据逻辑表达式稍作修改。</p></li><li><p>$u$ 是 $XOR$<br>说明两个儿子节点一个是 $1$，另一个是 $0$。根据假设，节点 $u$ 的值改变了，那么势必因为两个儿子之一的值改变了。递归搜索两个儿子。</p></li><li><p>$u$ 是 $NOT$<br>儿子的值改变了，递归搜索儿子节点。</p></li><li><p>$u$ 是 $IN$<br>输入改变了，记录这个 $u$，说明这个输入改变可以导致根节点的值发生改变。</p></li></ol><p>这样我们就可以从根节点开始搜索，一步步假设某节点的值发生改变，推算出哪个输入的改变会导致根节点值的改变。输出时只要对于有标记的节点，改变根节点的输出即可；否则输出 <code>ori[1]</code>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> next[<span class="number">2</span>];</span><br><span class="line">    State() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">        next[<span class="number">0</span>] = next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ori[N], vis[N];  <span class="comment">// vis[i] 为 1，表示改变 i 节点会改变根节点的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = a[u].next[<span class="number">0</span>], r = a[u].next[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">char</span> op = a[u].s[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">'A'</span>) &#123;        <span class="comment">// AND</span></span><br><span class="line">        <span class="keyword">return</span> ori[u] = dfs(l) &amp; dfs(r);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'O'</span>) &#123; <span class="comment">// OR</span></span><br><span class="line">        <span class="keyword">return</span> ori[u] = dfs(l) | dfs(r);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'X'</span>) &#123; <span class="comment">// XOR</span></span><br><span class="line">        <span class="keyword">return</span> ori[u] = dfs(l) ^ dfs(r);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'N'</span>) &#123; <span class="comment">// NOT</span></span><br><span class="line">        <span class="keyword">return</span> ori[u] = !dfs(l);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                <span class="comment">// IN</span></span><br><span class="line">        <span class="keyword">return</span> ori[u] = l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = a[u].next[<span class="number">0</span>], r = a[u].next[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">char</span> op = a[u].s[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">'A'</span>) &#123;        <span class="comment">// AND</span></span><br><span class="line">        <span class="keyword">if</span> (ori[u] == <span class="number">1</span>) &#123;</span><br><span class="line">            solve(l); solve(r);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ori[l] == <span class="number">0</span> &amp;&amp; ori[r] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (ori[l] == <span class="number">0</span>) solve(l);</span><br><span class="line">            <span class="keyword">if</span> (ori[r] == <span class="number">0</span>) solve(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'O'</span>) &#123; <span class="comment">// OR</span></span><br><span class="line">        <span class="keyword">if</span> (ori[u] == <span class="number">0</span>) &#123;</span><br><span class="line">            solve(l); solve(r);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ori[l] == <span class="number">1</span> &amp;&amp; ori[r] == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (ori[l] == <span class="number">1</span>) solve(l);</span><br><span class="line">            <span class="keyword">if</span> (ori[r] == <span class="number">1</span>) solve(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'X'</span>) &#123; <span class="comment">// XOR</span></span><br><span class="line">        solve(l); solve(r);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'N'</span>) &#123; <span class="comment">// NOT</span></span><br><span class="line">        solve(l);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                <span class="comment">// IN</span></span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, a[i].s);</span><br><span class="line">        <span class="keyword">if</span> (a[i].s[<span class="number">0</span>] != <span class="string">'I'</span> &amp;&amp; a[i].s[<span class="number">0</span>] != <span class="string">'N'</span>) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a[i].next[<span class="number">0</span>], &amp;a[i].next[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i].next[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>);     <span class="comment">// 计算原来的取值</span></span><br><span class="line">    </span><br><span class="line">    solve(<span class="number">1</span>);   <span class="comment">// 假设根节点的值发生改变</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (a[i].s[<span class="number">0</span>] == <span class="string">'I'</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, ori[<span class="number">1</span>] ^ vis[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给出一个以 $1$ 为根的有 $n$ 个节点的树，树的每个节点表示一个输入，或者一个逻辑关系。每个逻辑关系根据儿子节点的值，套入逻辑关系式，计算出当前节点的值。&lt;br&gt;现在让你求出，只改变任一个输入节点的值，根节点的取值。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="题解" scheme="http://yoursite.com/categories/ACM/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="dfs" scheme="http://yoursite.com/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>「Codeforces 1010C」Border - 群论</title>
    <link href="http://yoursite.com/2018/07/28/20180728-cf1010c/"/>
    <id>http://yoursite.com/2018/07/28/20180728-cf1010c/</id>
    <published>2018-07-28T09:10:23.000Z</published>
    <updated>2018-07-28T09:16:37.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出钞票面额的种类数 $n$，第 $i$ 种钞票的面额为 $a_i$。这 $n$ 种面额的钞票你均有无限张。现在让你求出，对这些钞票进行任意组合，得到总金额的 $k$ 进制表示后，有可能的个位数字。</p><a id="more"></a><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://codeforces.com/problemset/problem/1010/C" target="_blank" rel="noopener">Codeforces 1010C</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>最多有 $0\sim k-1$ 这 $k$ 种可能，把它们看成模 $k$ 加法群，记为 $G$。</p><p>考虑只取一种面额的钞票时，面额对 $k$ 取模的结果（记为 $r$），就是只取一张本面额钞票所得到的个位数字，且显然 $2r\pmod k, 3r\pmod k, \ldots$ 都可以得到。这些值组成了一个以 $r$ 为生成元的，以模 $k$ 加法为运算的循环群。显然这个群是 $G$ 的子群。且这个群的最小生成元为 $gcd(r, k)$ 。</p><p>记 $H_i$ 表示最小生成元为 $i$ 的满足上述性质的群。考虑有两种面额的钞票，当分别只取一种钞票时，我们得到群 $H_i$ 和 $H_j$。当我们混合取两种钞票时，我们得到两个群的和，这个群的最小生成元为 $H_{gcd(i, j)}$。显然这个群也是 $G$ 的子群。</p><p>考虑 $n$ 种面额的钞票，这些钞票单独取时，得到的群的最小生成元记为 $r_i$，则当混合取用这些钞票时，得到的群的最小生成元为 $gcd(r_1, r_2, \ldots, r_n)$。原题所求即为这个群的所有元素。</p><p>因此我们只需要维护最小生成元 $g$。开始时 $g = k$，根据每个输入，维护 $g = gcd(g, a_i \% k)$，然后输出根据这个最小生成元，生成的循环群的所有元素即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a % b == <span class="number">0</span> ? b : gcd(b, a % b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">int</span> g = k, a;   <span class="comment">// g 是最小生成元</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        a %= k;</span><br><span class="line">        g = gcd(a, g);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; k / g &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// 群中元素个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i += g) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给出钞票面额的种类数 $n$，第 $i$ 种钞票的面额为 $a_i$。这 $n$ 种面额的钞票你均有无限张。现在让你求出，对这些钞票进行任意组合，得到总金额的 $k$ 进制表示后，有可能的个位数字。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="题解" scheme="http://yoursite.com/categories/ACM/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="群论" scheme="http://yoursite.com/tags/%E7%BE%A4%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>「Codeforces 1010B」Rocket - 交互式 + 二分</title>
    <link href="http://yoursite.com/2018/07/28/20180728-cf1010b/"/>
    <id>http://yoursite.com/2018/07/28/20180728-cf1010b/</id>
    <published>2018-07-28T09:04:53.000Z</published>
    <updated>2018-07-28T09:16:30.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>交互式题目，通过和机器的沟通猜一个正整数 $x\ (x\le m)$。<br>每次你询问一个正整数 $y\ (y\le m)$，机器理应返回的正确答案为 $\begin{cases}-1 &amp; x &lt; y \\ 0 &amp; x = y \\  1 &amp; x &gt; y\end{cases}$<br>但是机器有些故障，他有时返回和正确答案互为相反数的结果，这个规律通过长度为 $n$ 的数列 $p$ 描述。数列 $p$ 的每一项是 $1$ 或者是 $0$。对于第 $k$ 次询问，如果数列的第 $(k-1)\pmod n + 1$ 项是 $0$，则返回相反的答案；否则返回正确答案。<br>现在你可以给出最多 $60$ 次询问，根据机器返回的值确定这个要猜测的数字 $x$。</p><a id="more"></a><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://codeforces.com/problemset/problem/1010/B" target="_blank" rel="noopener">Codeforces 1010B</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>考虑询问为 $y = 1$ 时，正确答案只能为 $1$ 或 $0$。由于 $n$ 不超过 $30$，因此我们的前 $30$ 次询问可以全部为 $y = 1$，这样就可以知道数列 $p$ 的每一项的值。<br>自此，机器返回的每个结果都可以根据数列 $p$ 的值进行调整，可以确保得到正确信息。因此我们只需要在 $1\sim m$ 之间二分，即可在剩余 $30$ 步内得到 $x$ 的值。（$\log_2{10^9} = 29.897 &lt; 30$）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;   <span class="comment">// 询问 a，return 机器的返回值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = ask(mid) * p[cur % n];</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ans == <span class="number">-1</span>) solve(l, mid, cur + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> solve(mid + <span class="number">1</span>, r, cur + <span class="number">1</span>);</span><br><span class="line">&#125;   <span class="comment">// 第 cur 次询问</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        p[i] = ask(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (p[i] == <span class="number">0</span>) <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 如果正确答案就是 1，退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    solve(<span class="number">1</span>, m, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;交互式题目，通过和机器的沟通猜一个正整数 $x\ (x\le m)$。&lt;br&gt;每次你询问一个正整数 $y\ (y\le m)$，机器理应返回的正确答案为 $\begin{cases}-1 &amp;amp; x &amp;lt; y \\ 0 &amp;amp; x = y \\  1 &amp;amp; x &amp;gt; y\end{cases}$&lt;br&gt;但是机器有些故障，他有时返回和正确答案互为相反数的结果，这个规律通过长度为 $n$ 的数列 $p$ 描述。数列 $p$ 的每一项是 $1$ 或者是 $0$。对于第 $k$ 次询问，如果数列的第 $(k-1)\pmod n + 1$ 项是 $0$，则返回相反的答案；否则返回正确答案。&lt;br&gt;现在你可以给出最多 $60$ 次询问，根据机器返回的值确定这个要猜测的数字 $x$。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="题解" scheme="http://yoursite.com/categories/ACM/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="交互式" scheme="http://yoursite.com/tags/%E4%BA%A4%E4%BA%92%E5%BC%8F/"/>
    
      <category term="二分" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>「Codeforces 1010A」Fly - 二分答案</title>
    <link href="http://yoursite.com/2018/07/28/20180728-cf1010a/"/>
    <id>http://yoursite.com/2018/07/28/20180728-cf1010a/</id>
    <published>2018-07-28T08:59:56.000Z</published>
    <updated>2018-07-28T09:18:05.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有 $n$ 个行星，标号 $1\sim n$。飞行器从 $1$ 出发，经过 $2,3,\ldots, n-1$ 到达 $n$，再从 $n$ 出发到达 $1$。<br>飞行器重 $m$ 吨，且其携带的燃油也有重量。每次飞行器从行星 $i$ 起飞，每消耗 $1$ 吨燃油可以支持 $a_i$ 的重量；每次飞行器降落在行星 $i$，每消耗 $1$ 吨燃油可以支持 $b_i$ 的重量。只有飞行器拥有可以支撑当前总重量（飞行器重量 $+$ 当前燃油重量）的燃油时，才可以成功起飞或降落。可以认为起飞和降落瞬间完成。<br>求旅程开始时携带燃油的最小吨数。</p><a id="more"></a><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://codeforces.com/problemset/problem/1010/A" target="_blank" rel="noopener">Codeforces 1010A</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>记在某次起飞 / 降落前，有燃油 $w$ 吨。<br>首先考虑，如果某个 $a_i$ 或 $b_i$ 为 $1$，则本次所需燃油数为 $m + w &gt; w$，不合法。因此先判断输入中是否存在 $1$，若存在，则直接输出 $-1$。</p><p>考虑这个问题对应的判断问题。假设旅程开始前，共有 $W$ 吨燃油。则我们可以直接遍历这个旅程的每次起飞和降落，判断开始前的 $W$ 吨燃油是否足够。判定问题的时间复杂度为 $O(n)$。且对于单调增的 $W$，必然会存在一个值作为能否完成旅程的分界线。（单调性，满足二分条件）</p><p>因此我们可以二分这个 $W$，对每个确定的 $W$ 判定是否可以完成旅途。当二分的间距小于精度时，输出这个 $W$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">2e-7</span>;    <span class="comment">// 精度，1e-7 TLE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ok</span><span class="params">(<span class="keyword">double</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> tot = m + w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        tot -= tot / a[i];  <span class="comment">// 起飞</span></span><br><span class="line">        <span class="keyword">if</span> (tot &lt; m &amp;&amp; <span class="built_in">fabs</span>(tot - m) &gt; EPS) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> d = (i + <span class="number">1</span>) % n;</span><br><span class="line">        tot -= tot / b[d];</span><br><span class="line">        <span class="keyword">if</span> (tot &lt; m &amp;&amp; <span class="built_in">fabs</span>(tot - m) &gt; EPS) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;   <span class="comment">// 判定问题</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(l - r) &lt; EPS) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span> (ok(mid)) <span class="keyword">return</span> solve(l, mid);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> solve(mid, r);</span><br><span class="line">&#125;   <span class="comment">// 二分</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="number">1</span>) flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">        <span class="keyword">if</span> (b[i] == <span class="number">1</span>) flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123; <span class="comment">// a 或 b 中存在 1</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">8</span>) &lt;&lt; solve(EPS, <span class="number">1e9</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;有 $n$ 个行星，标号 $1\sim n$。飞行器从 $1$ 出发，经过 $2,3,\ldots, n-1$ 到达 $n$，再从 $n$ 出发到达 $1$。&lt;br&gt;飞行器重 $m$ 吨，且其携带的燃油也有重量。每次飞行器从行星 $i$ 起飞，每消耗 $1$ 吨燃油可以支持 $a_i$ 的重量；每次飞行器降落在行星 $i$，每消耗 $1$ 吨燃油可以支持 $b_i$ 的重量。只有飞行器拥有可以支撑当前总重量（飞行器重量 $+$ 当前燃油重量）的燃油时，才可以成功起飞或降落。可以认为起飞和降落瞬间完成。&lt;br&gt;求旅程开始时携带燃油的最小吨数。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="题解" scheme="http://yoursite.com/categories/ACM/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="二分答案" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
      <category term="二分" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>「Codeforces Round 499 (Div. 2)」A - F</title>
    <link href="http://yoursite.com/2018/07/28/20180728-cfround499div2/"/>
    <id>http://yoursite.com/2018/07/28/20180728-cfround499div2/</id>
    <published>2018-07-28T06:46:18.000Z</published>
    <updated>2018-07-28T09:15:11.021Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-Stages"><a href="#A-Stages" class="headerlink" title="A. Stages"></a>A. Stages</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个长度为 $n$ 的字符串，让你从中选出 $k$ 个字母从小到大排成一列。要求相邻字母的 $ascii$ 码之差不小于 $2$。且这 $k$ 个字母的 $ascii$ 码之和最小。如果找不出这样的 $k$ 个字母，输出 $-1$。</p><a id="more"></a><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://codeforces.com/problemset/problem/1011/A" target="_blank" rel="noopener">Codeforces 1011A</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>贪心地优先选择<strong>满足题意</strong>的 $ascii$ 码最小的字母。<br>先排序，然后做 $k$ 次选取。每次选出最小的字母，然后删掉原字符串中，与这个字母之差小于 $2$ 的字母。<br>如果不能做 $k$ 次选取，则输出 $-1$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%s"</span>, &amp;n ,&amp;k, s);</span><br><span class="line">    <span class="built_in">std</span>::sort(s, s + n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; que;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) que.push(s[i]);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; k &amp;&amp; !que.empty()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = que.front(); que.pop();</span><br><span class="line">        ans += c - <span class="string">'a'</span> + <span class="number">1</span>;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">while</span> (!que.empty() &amp;&amp; que.front() - c &lt; <span class="number">2</span>) que.pop();</span><br><span class="line">            <span class="comment">// 删除原串中与被选字母之差小于 2 的字母</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt == k ? ans : <span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 若没有完成 k 次选取，输出 -1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-Planning-The-Expedition"><a href="#B-Planning-The-Expedition" class="headerlink" title="B. Planning The Expedition"></a>B. Planning The Expedition</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>$n$ 个宇航员，$m$ 份粮食，第 $i$ 份粮食的种类为 $a_i$。每个宇航员每天吃一份粮食，且旅程中这个宇航员只能吃一种粮食。不同的宇航员吃的粮食种类可以不同。求旅程最多满足几天的口粮。</p><h2 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h2><p><a href="http://codeforces.com/problemset/problem/1011/B" target="_blank" rel="noopener">Codeforces 1011B</a></p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>数据规模较小，因此可以枚举天数 $d$。<br>记第 $i$ 种口粮有 $cnt_i$ 份，则在旅程中这种口粮可供 $\frac{cnt_i}{d}$ 个宇航员食用（注意是整数除法）。<br>因此可以养活的宇航员的最大数目为 $\sum \limits_i \frac{cnt_i}{d}$，判断这个数目与 $n$ 的大小关系即可。<br>输出满足条件的最大的 $d$。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, a[N], cnt[N]; <span class="comment">// cnt[i]: 第 i 种口粮的份数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        ++cnt[a[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m / n; i &gt; <span class="number">0</span>; --i) &#123;   <span class="comment">// 口粮最多供应 m / n 天</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">100</span>; ++j) &#123;</span><br><span class="line">            sum += cnt[j] / i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt;= n) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">// 满足条件，输出这个最大天数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;        <span class="comment">// 没有满足条件的天数，输出 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-Fly"><a href="#C-Fly" class="headerlink" title="C. Fly"></a>C. Fly</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>有 $n$ 个行星，标号 $1\sim n$。飞行器从 $1$ 出发，经过 $2,3,\ldots, n-1$ 到达 $n$，再从 $n$ 出发到达 $1$。<br>飞行器重 $m$ 吨，且其携带的燃油也有重量。每次飞行器从行星 $i$ 起飞，每消耗 $1$ 吨燃油可以支持 $a_i$ 的重量；每次飞行器降落在行星 $i$，每消耗 $1$ 吨燃油可以支持 $b_i$ 的重量。只有飞行器拥有可以支撑当前总重量（飞行器重量 $+$ 当前燃油重量）的燃油时，才可以成功起飞或降落。可以认为起飞和降落瞬间完成。<br>求旅程开始时携带燃油的最小吨数。</p><h2 id="链接-2"><a href="#链接-2" class="headerlink" title="链接"></a>链接</h2><p><a href="http://codeforces.com/problemset/problem/1010/A" target="_blank" rel="noopener">Codeforces 1010A</a></p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>详见 <a href="https://hyp1231.github.io/2018/07/28/20180728-cf1010a/" target="_blank" rel="noopener">「Codeforces 1010A」Fly - 二分答案</a></p><h1 id="D-Rocket"><a href="#D-Rocket" class="headerlink" title="D. Rocket"></a>D. Rocket</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>交互式题目，通过和机器的沟通猜一个正整数 $x\ (x\le m)$。<br>每次你询问一个正整数 $y\ (y\le m)$，机器理应返回的正确答案为 $\begin{cases}-1 &amp; x &lt; y \\ 0 &amp; x = y \\  1 &amp; x &gt; y\end{cases}$<br>但是机器有些故障，他有时返回和正确答案互为相反数的结果，这个规律通过长度为 $n$ 的数列 $p$ 描述。数列 $p$ 的每一项是 $1$ 或者是 $0$。对于第 $k$ 次询问，如果数列的第 $(k-1)\pmod n + 1$ 项是 $0$，则返回相反的答案；否则返回正确答案。<br>现在你可以给出最多 $60$ 次询问，根据机器返回的值确定这个要猜测的数字 $x$。</p><h2 id="链接-3"><a href="#链接-3" class="headerlink" title="链接"></a>链接</h2><p><a href="http://codeforces.com/problemset/problem/1010/B" target="_blank" rel="noopener">Codeforces 1010B</a></p><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>详见 <a href="https://hyp1231.github.io/2018/07/28/20180728-cf1010b/" target="_blank" rel="noopener">「Codeforces 1010B」Rocket - 交互式 + 二分</a></p><h1 id="E-Border"><a href="#E-Border" class="headerlink" title="E. Border"></a>E. Border</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>给出钞票面额的种类数 $n$，第 $i$ 种钞票的面额为 $a_i$。这 $n$ 种面额的钞票你均有无限张。现在让你求出，对这些钞票进行任意组合，得到总金额的 $k$ 进制表示后，有可能的个位数字。</p><h2 id="链接-4"><a href="#链接-4" class="headerlink" title="链接"></a>链接</h2><p><a href="http://codeforces.com/problemset/problem/1010/C" target="_blank" rel="noopener">Codeforces 1010C</a></p><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><p>详见 <a href="https://hyp1231.github.io/2018/07/28/20180728-cf1010c/" target="_blank" rel="noopener">「Codeforces 1010C」Border - 群论</a></p><h1 id="F-Mars-rover"><a href="#F-Mars-rover" class="headerlink" title="F. Mars rover"></a>F. Mars rover</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>给出一个以 $1$ 为根的有 $n$ 个节点的树，树的每个节点表示一个输入，或者一个逻辑关系。每个逻辑关系根据儿子节点的值，套入逻辑关系式，计算出当前节点的值。<br>现在让你求出，只改变任一个输入节点的值，根节点的取值。</p><h2 id="链接-5"><a href="#链接-5" class="headerlink" title="链接"></a>链接</h2><p><a href="http://codeforces.com/problemset/problem/1010/D" target="_blank" rel="noopener">Codeforces 1010D</a></p><h2 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h2><p>详见 <a href="https://hyp1231.github.io/2018/07/28/20180728-cf1010d/" target="_blank" rel="noopener">「Codeforces 1010D」Mars rover - dfs</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;A-Stages&quot;&gt;&lt;a href=&quot;#A-Stages&quot; class=&quot;headerlink&quot; title=&quot;A. Stages&quot;&gt;&lt;/a&gt;A. Stages&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给一个长度为 $n$ 的字符串，让你从中选出 $k$ 个字母从小到大排成一列。要求相邻字母的 $ascii$ 码之差不小于 $2$。且这 $k$ 个字母的 $ascii$ 码之和最小。如果找不出这样的 $k$ 个字母，输出 $-1$。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="题解" scheme="http://yoursite.com/categories/ACM/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Codeforces Round" scheme="http://yoursite.com/tags/Codeforces-Round/"/>
    
  </entry>
  
  <entry>
    <title>「Codeforces 1006F」Xor-Paths - 双向bfs</title>
    <link href="http://yoursite.com/2018/07/17/20180717-cf1006f/"/>
    <id>http://yoursite.com/2018/07/17/20180717-cf1006f/</id>
    <published>2018-07-17T05:46:33.000Z</published>
    <updated>2018-07-28T06:54:13.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给定 $n \times m$ 的矩阵，以及一个整数 $k$。<br>定义路径为，从 $(1,1)$ 出发，只能向右 / 下方走，到达 $(n, m)$ 的行走方案。<br>定义路径的权重为，路径经过的整数的 $xor$ 之和。<br>求权重为 $k$ 的路径的条数。</p><a id="more"></a><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://codeforces.com/problemset/problem/1006/F" target="_blank" rel="noopener">Codeforces 1006F</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>定义从路径一端到 $(x,y)$ 的某条路径上的整数的 $xor$ 之和为 $(x,y)$ 处的<strong>状态</strong>。</p><p>由于 $n$ 和 $m$ 的范围均为 $20$ 之内，考虑暴力搜索。对于每个位置，之后都有两种状态转移（向下 / 向右）。因此我们将矩阵按照 $m + n$ 的值进行分层，如果从起点开始 $bfs$，易知每次状态转移使层数加一，每一层的状态数不超过上一层的二倍，故直接 $bfs$ 的状态数不超过 $2 ^ {m+ n}$ ，但这个量级是我们不能接受的。</p><p>而考虑起点和终点的值都是唯一且确定的，我们可以从起点和终点同时采用 $bfs$。因此我们规定 $\frac{m + n}{2}$ 为中心层，两个 $bfs$ 一到中心层则停止搜索，这样在中心层，如果有重合的状态则说明有合法路径。</p><p>为了记录合法路径的数目，我们需要记录某一个 $bfs$ （这里不妨设为从起点出发的）到达状态 $val$ 的路径数。在实现上，我们使用 $STL$ 库中的 $map$，形成状态到路径数的映射。这样先实现从起点出发的 $bfs$，得到中间层每个位置各个状态的路径数；再做另一个 $bfs$，对于每个到中间层的状态，把第一个 $bfs$ 中计算出的该状态对应的路径数加到总的 $ans$ 中。</p><p>这样搜索到中间层的状态数不超过 $2^{\frac{m+n}{2}}$，$map$ 的复杂度 $O(\log {2^{\frac{m+n}{2}}}) = O(\frac{m+ n}{2}\log 2) = O(\frac{m + n}{2})$，总复杂度 $O(\frac{m+n}{2} \cdot 2^{\frac{m+n}{2}})$ 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    LL val;</span><br><span class="line">    State(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>, LL val = <span class="number">0</span>) : x(x), y(y), val(val) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, mid;</span><br><span class="line">LL a[N][N], k;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录中间层 状态-&gt;路径数 的映射</span></span><br><span class="line"><span class="comment">// 由于 x + y = (n + m) / 2，我们确定了 x 即可确定 y</span></span><br><span class="line"><span class="comment">// 因此 res[x][st] 代表中间层横坐标为 x 的点，状态为 st 的路径数目</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;LL, <span class="keyword">int</span>&gt; res[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    mid = (n + m - <span class="number">2</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;State&gt; que1, que2;</span><br><span class="line">    que1.push(State(<span class="number">0</span>, <span class="number">0</span>, a[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line">    <span class="keyword">while</span> (!que1.empty()) &#123;</span><br><span class="line">        State tmp = que1.front(); que1.pop();</span><br><span class="line">        <span class="keyword">int</span> x = tmp.x, y = tmp.y;</span><br><span class="line">        LL val = tmp.val;</span><br><span class="line">        <span class="keyword">if</span> (x + y == mid) &#123; <span class="comment">// 到达中心线</span></span><br><span class="line">            <span class="keyword">if</span> (res[x].count(val)) &#123;</span><br><span class="line">                ++res[x][val];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[x][val] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + <span class="number">1</span> != n) que1.push(State(x + <span class="number">1</span>, y, val ^ a[x + <span class="number">1</span>][y]));</span><br><span class="line">            <span class="keyword">if</span> (y + <span class="number">1</span> != m) que1.push(State(x, y + <span class="number">1</span>, val ^ a[x][y + <span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    que2.push(State(n - <span class="number">1</span>, m - <span class="number">1</span>, k));</span><br><span class="line">    <span class="keyword">while</span> (!que2.empty()) &#123;</span><br><span class="line">        State tmp = que2.front(); que2.pop();</span><br><span class="line">        <span class="keyword">int</span> x = tmp.x, y = tmp.y;</span><br><span class="line">        LL val = tmp.val;</span><br><span class="line">        <span class="keyword">if</span> (x + y == mid) &#123;</span><br><span class="line">            ans += res[x][val];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (x - <span class="number">1</span> &gt;= <span class="number">0</span>) que2.push(State(x - <span class="number">1</span>, y, val ^ a[x][y]));</span><br><span class="line">            <span class="keyword">if</span> (y - <span class="number">1</span> &gt;= <span class="number">0</span>) que2.push(State(x, y - <span class="number">1</span>, val ^ a[x][y]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给定 $n \times m$ 的矩阵，以及一个整数 $k$。&lt;br&gt;定义路径为，从 $(1,1)$ 出发，只能向右 / 下方走，到达 $(n, m)$ 的行走方案。&lt;br&gt;定义路径的权重为，路径经过的整数的 $xor$ 之和。&lt;br&gt;求权重为 $k$ 的路径的条数。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="题解" scheme="http://yoursite.com/categories/ACM/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="双向bfs" scheme="http://yoursite.com/tags/%E5%8F%8C%E5%90%91bfs/"/>
    
  </entry>
  
  <entry>
    <title>「Codeforces 1009E」Intercity Travelling - 组合数学</title>
    <link href="http://yoursite.com/2018/07/16/20180716-cf1009e/"/>
    <id>http://yoursite.com/2018/07/16/20180716-cf1009e/</id>
    <published>2018-07-16T00:55:28.000Z</published>
    <updated>2018-07-16T02:46:12.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>Leha 想开车去 Saratov，这段旅途看作 $0$ 到 $n$ 的一维直线。<br>如果 Leha 从起点出发或者从休息点出发，连续驾驶 $k$ 千米，则需要消耗的体能为 $a_1 + a_2 + \ldots + a_k$。<br>每个整点 $t, (1 \le t &lt; n)$ 都可能拥有一个休息点，每个休息点存在或不存在的概率相等。<br>记 Leha 整个旅程消耗的体能的期望为 $p$，求 $p\cdot 2^{n - 1}$。</p><a id="more"></a><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://codeforces.com/problemset/problem/1009/E" target="_blank" rel="noopener">Codeforces 1009E</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>旅途中共有 $n - 1$ 个整点，故有 $2^{n - 1}$ 种可能的休息点摆放方案，故 $p\cdot 2^{n - 1}$ 为所有可能情况消耗体能之和。</p><p>我们先考虑总和中的 $a_1$ 的数量。由于每个休息点之后紧邻的 $1km$ 路程一定消耗 $a_1$ 的体能，因此某种摆放方案中 $a_1$ 的数量等于休息点个数加一（起点之后一定消耗 $a_1$）。考虑有 $j$ 个休息点时，有 $C_{n-1}^{j}$ 种摆放方案，故 $j$ 个休息点的情况下 $a_1$ 的数量和为 $(j + 1)C_{n-1}^j$。</p><p>记 $N_1$ 为所有摆放方案下 $a_1$ 的数量和，则有<br>$$<br>N_1 = \sum \limits_{i = 1}^{n} i \cdot C_{n-1}^{i-1}<br>$$<br>即 $N_1 = 1 \cdot C_{n-1}^{0} + 2 \cdot C_{n - 1}^{1} + \ldots + n \cdot C_{n-1}^{n-1}$</p><p>又由于 $C_{n -1}^{i} = C_{n - 1}^{n-1 -i}$，有 $N_1 = 1 \cdot C_{n-1}^{n-1} + 2 \cdot C_{n - 1}^{n-2} + \ldots + n \cdot C_{n-1}^{0}$</p><p>两式加和，有 $2 N_1 = (n + 1)\sum\limits_{i = 1}^{n}C_{n-1}^{i-1} = (n+1)\cdot 2^{n-1}$，即 $N_1 = (n + 1) \cdot 2^{n - 2}$</p><p>同理，有 $N_i = (n + 2 - i)\cdot 2^{n-1 - i}$，则<br>$$<br>p\cdot 2^{n - 1} = \sum\limits_{i=1}^{n} N_ia_i = \sum\limits_{i = 1} ^n (n + 2 - i) \cdot 2 ^{n - 1 - i} \cdot a_i<br>$$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::iostream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">LL a[N], p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>), <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>; p[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">    LL m = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;   <span class="comment">// 预处理系数，即 Ni</span></span><br><span class="line">        m = (m &lt;&lt; <span class="number">1</span>) % mod;         <span class="comment">// 2^(i - 1)</span></span><br><span class="line">        p[i] = (m * (i + <span class="number">2</span>)) % mod; <span class="comment">// (i + 2) * 2^(i - 1)</span></span><br><span class="line">    &#125;</span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        sum = (sum + p[n - i - <span class="number">1</span>] * a[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;Leha 想开车去 Saratov，这段旅途看作 $0$ 到 $n$ 的一维直线。&lt;br&gt;如果 Leha 从起点出发或者从休息点出发，连续驾驶 $k$ 千米，则需要消耗的体能为 $a_1 + a_2 + \ldots + a_k$。&lt;br&gt;每个整点 $t, (1 \le t &amp;lt; n)$ 都可能拥有一个休息点，每个休息点存在或不存在的概率相等。&lt;br&gt;记 Leha 整个旅程消耗的体能的期望为 $p$，求 $p\cdot 2^{n - 1}$。&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="题解" scheme="http://yoursite.com/categories/ACM/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="组合数学" scheme="http://yoursite.com/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>「HDU 5677」 ztr loves substring - Manacher + 多重背包</title>
    <link href="http://yoursite.com/2018/07/10/20180710-hdu5677/"/>
    <id>http://yoursite.com/2018/07/10/20180710-hdu5677/</id>
    <published>2018-07-10T09:55:55.000Z</published>
    <updated>2018-07-16T00:56:47.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出 $N$ 个字符串，所有字符串的连续回文子串构成一个多重集合 $S$<br>求 $S$ 中是否存在恰好 $K$ 个串，使它们的长度之和为 $L$</p><a id="more"></a><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5677" target="_blank" rel="noopener">HDU5677 ztr loves substring</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>只与每个串的长度有关，故应先预处理出每个长度的回文串的数量。</p><p>使用 Manacher 算法计算出以串的各个位置为中心的最大回文串长度。若以 $s_i$ 为中心的最大回文串的长度为 $l$（不妨假设它为偶数），考虑逐步去掉两侧字符就可以造出更多回文子串。因此长度为 $2,4,\ldots, l$ 的子串的计数器分别加一（若 $l$ 为奇数，同理）。这样我们就得到了每个长度的串的数量，</p><p>考虑选出 $K​$ 个串使它们长度之和为 $L​$。即选出 $K​$ 个物品，填满容量为 $L​$ 的背包，每种物品的个数已知，是多重背包问题。设计 $dp[i][j]​$ 表示当前已经选了 $i​$ 个串，放在容量为 $j​$ 的背包中的最大容量。记放入新串后数量为 $num​$，当前背包容量为 $p​$，新增串个数为 $mul​$，新增子串长 $i​$，则状态转移方程为:<br>$dp[num][p] = MAX(dp[num][p], dp[num - mul][p - mul \cdot i] + mul\cdot i)​$</p><div class="note warning"><p>Hint 1: 转移要求在 $num = mul$（第一次添加串）或 $dp[num-mul][p - mul\cdot i]$ 不为 $0$ 时才转移（说明存在上一个状态）。<br>Hint 2: 使用二进制优化加速多重背包。</p></div><p>记长度为 $i$ 的回文子串的数量为 $W_i$。读入和 $N$ 次 Manacher 是 $O(NL)$ 的，多重背包是 $O\left((\sum \limits_{i = 1}^L\log{W_i})KL\right)$。总时间复杂度 $O\left((\sum \limits_{i = 1}^L\log{W_i})KL + NL\right)$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">128</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> mid_c = <span class="string">'$'</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> side_c = <span class="string">'@'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, l;</span><br><span class="line"><span class="keyword">char</span> s[N][N];</span><br><span class="line"><span class="keyword">char</span> s2[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> len, r[N][N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">char</span> s1[])</span> </span>&#123;</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    s2[len++] = side_c;</span><br><span class="line">    s2[len++] = mid_c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        s2[len++] = s1[i];</span><br><span class="line">        s2[len++] = mid_c;</span><br><span class="line">    &#125;</span><br><span class="line">    s2[len + <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manacher</span><span class="params">(<span class="keyword">char</span> s1[], <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    prepare(s1);</span><br><span class="line">    <span class="built_in">memset</span>(r[id], <span class="number">0</span>, <span class="keyword">sizeof</span>(r[id]));</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>, p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; i)x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> x = <span class="built_in">std</span>::min(p - i, r[id][<span class="number">2</span> * mid - i]);</span><br><span class="line">        <span class="keyword">while</span> (s2[i - x] == s2[i + x]) ++x;</span><br><span class="line">        <span class="keyword">if</span> (i + x &gt; p) &#123;</span><br><span class="line">            p = i + x;</span><br><span class="line">            mid = i;</span><br><span class="line">        &#125;</span><br><span class="line">        r[id][i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt[N], dp[N][N];</span><br><span class="line"><span class="comment">// dp[i][j] 代表 i 个子串拼接成的串的最大长度（不超过 j）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;k, &amp;l);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            Manacher(s[i], i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = r[i][j] - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (tmp &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">while</span> (tmp &gt; <span class="number">0</span>) &#123;           <span class="comment">// 最长子串逐步去掉侧边字母也是子串</span></span><br><span class="line">                    ++cnt[tmp];</span><br><span class="line">                    tmp -= <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= l; ++i) &#123;      <span class="comment">// 枚举子串长度</span></span><br><span class="line">            <span class="keyword">int</span> sum = cnt[i];               <span class="comment">// 长度为 i 的子串数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; sum; j &lt;&lt;= <span class="number">1</span>) &#123; <span class="comment">// 二进制优化</span></span><br><span class="line">                <span class="keyword">int</span> mul = <span class="built_in">std</span>::min(sum, j);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> p = l; p &gt;= mul * i; --p)      <span class="comment">// 枚举长度</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> num = mul; num &lt;= k; ++num)<span class="comment">// 枚举已选字符串个数</span></span><br><span class="line">                        <span class="keyword">if</span> (num == mul || dp[num - mul][p - mul * i] &gt; <span class="number">0</span>)</span><br><span class="line">                            <span class="comment">// 如果本串是第一次被选，或存在选了 p - mul * i 个串的方案</span></span><br><span class="line">                            dp[num][p] = <span class="built_in">std</span>::max(dp[num][p], </span><br><span class="line">                                                  dp[num - mul][p - mul * i] + mul * i);</span><br><span class="line">                sum -= mul;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, (dp[k][l] == l ? <span class="string">"True"</span> : <span class="string">"False"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给出 $N$ 个字符串，所有字符串的连续回文子串构成一个多重集合 $S$&lt;br&gt;求 $S$ 中是否存在恰好 $K$ 个串，使它们的长度之和为 $L$&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="题解" scheme="http://yoursite.com/categories/ACM/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Manacher" scheme="http://yoursite.com/tags/Manacher/"/>
    
      <category term="多重背包" scheme="http://yoursite.com/tags/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>「CodeM2018复赛」 软件包管理器 - 二分答案 + 拓扑排序</title>
    <link href="http://yoursite.com/2018/07/08/20180708-codem/"/>
    <id>http://yoursite.com/2018/07/08/20180708-codem/</id>
    <published>2018-07-08T07:50:26.000Z</published>
    <updated>2018-07-28T09:17:58.384Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$n$ 个点的图，依次添加给出的 $m$ 条有向边。<br>每次添加后，如果图中有环，输出 $0$；否则输出 $1$。<br>$n \le 1e5, m \le 2e6$</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第一行两个正整数 $n$ 和 $m$。<br>之后 $m$ 行，每行两个正整数 $(u’, v’)$ 表示加密后的边，保证 $u’ \not = v’$</p><p>记上一个回答为 $ans$，实际的边为 $(u, v)$<br>则有 $\begin{cases}u’ =  (u + ans) \pmod n + 1\\ v’ = (v + ans) \pmod n  + 1\end{cases}$</p><p>最开始的 $ans$ 为 $0$</p><a id="more"></a><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.nowcoder.com/acm/contest/152/B" target="_blank" rel="noopener">CodeM2018复赛 软件包管理器</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>如果加了某条边后，图中出现环，那么这条边及以后的 $ans$ 应全为 $0$。<br>因此题意即为找到 $ans$ 序列的 $1$ 和 $0$ 的分界线。</p><p>考虑二分答案，每次判断 $1 \to mid$ 的边构成的图是否为 DAG。<br>如果对 $1 \to mid$ 的边建成的图可以做拓扑排序，则是 DAG；否则说明必有环。</p><p>由于拓扑排序时间复杂度 $O(n)$，总时间复杂度 $O(n\log{m})$。</p><div class="note warning"><p>Hint: 我们可以在读入数据的时候预处理出解密后的 $(u, v)$：<br>​    如果上一个 $ans$ 是 $0$，则 $u = (u’-1+n) \% n$ ；<br>​    否则，$u = (u’ - 2 + n) \% n$。$v$ 同理。</p></div><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    E(<span class="keyword">int</span> u = <span class="number">0</span>, <span class="keyword">int</span> v = <span class="number">0</span>) : u(u), v(v) &#123;&#125;</span><br><span class="line">&#125; pre_0[N &lt;&lt; <span class="number">1</span>], pre_1[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 如果上一个 ans 是 0，实际的边为 pre_0[i]；否则是 pre_1[i]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> degree[N];      <span class="comment">// 节点度数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> e_id, head[N];  <span class="comment">// e_id 记录边数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, next;</span><br><span class="line">    Edge(<span class="keyword">int</span> u = <span class="number">0</span>, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> next = <span class="number">0</span>) :u(u), v(v), next(next) &#123;&#125;</span><br><span class="line">&#125; e[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    e[++e_id].v = b;</span><br><span class="line">    e[e_id].u = a;</span><br><span class="line">    e[e_id].next = head[a];</span><br><span class="line">    head[a] = e_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    e_id = <span class="number">0</span>;</span><br><span class="line">    addedge(pre_0[<span class="number">0</span>].u, pre_0[<span class="number">0</span>].v);    <span class="comment">// 初始 ans 为 0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= id; ++i) &#123;      <span class="comment">// 假设前 id 条边构成 DAG</span></span><br><span class="line">        <span class="keyword">int</span> u = pre_1[i].u, v = pre_1[i].v;</span><br><span class="line">        addedge(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topo</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    build(id);  <span class="comment">// 建图</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(degree, <span class="number">0</span>, <span class="keyword">sizeof</span>(degree));</span><br><span class="line">    ++degree[pre_0[<span class="number">0</span>].v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= id; ++i)</span><br><span class="line">        ++degree[pre_1[i].v];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (degree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            que.push(i);</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span> (vis[v])<span class="keyword">continue</span>;</span><br><span class="line">            --degree[v];</span><br><span class="line">            <span class="keyword">if</span> (degree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                que.push(v);</span><br><span class="line">                vis[v] = <span class="literal">true</span>;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt == n;</span><br><span class="line">&#125;   <span class="comment">// 如果拓扑有序，返回 true，O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (topo(mid)) <span class="keyword">return</span> solve(mid, r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> solve(l, mid - <span class="number">1</span>);</span><br><span class="line">&#125;   <span class="comment">// 二分，返回最大的可以构成 DAG 的边数，即 [1, id] 可以构成 DAG，但 [1, id + 1] 不可以</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        --u; --v;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">0</span>) u = n;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="number">0</span>) v = n;  <span class="comment">// 取模</span></span><br><span class="line">        pre_0[i].u = u;</span><br><span class="line">        pre_0[i].v = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = pre_0[i].u - <span class="number">1</span>, v = pre_0[i].v - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">0</span>) u = n;</span><br><span class="line">        <span class="keyword">if</span> (v == <span class="number">0</span>) v = n;</span><br><span class="line">        pre_1[i].u = u;</span><br><span class="line">        pre_1[i].v = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = solve(<span class="number">0</span>, m - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (i &lt;= k));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;$n$ 个点的图，依次添加给出的 $m$ 条有向边。&lt;br&gt;每次添加后，如果图中有环，输出 $0$；否则输出 $1$。&lt;br&gt;$n \le 1e5, m \le 2e6$&lt;/p&gt;
&lt;h3 id=&quot;输入&quot;&gt;&lt;a href=&quot;#输入&quot; class=&quot;headerlink&quot; title=&quot;输入&quot;&gt;&lt;/a&gt;输入&lt;/h3&gt;&lt;p&gt;第一行两个正整数 $n$ 和 $m$。&lt;br&gt;之后 $m$ 行，每行两个正整数 $(u’, v’)$ 表示加密后的边，保证 $u’ \not = v’$&lt;/p&gt;
&lt;p&gt;记上一个回答为 $ans$，实际的边为 $(u, v)$&lt;br&gt;则有 $\begin{cases}u’ =  (u + ans) \pmod n + 1\\ v’ = (v + ans) \pmod n  + 1\end{cases}$&lt;/p&gt;
&lt;p&gt;最开始的 $ans$ 为 $0$&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://yoursite.com/categories/ACM/"/>
    
      <category term="题解" scheme="http://yoursite.com/categories/ACM/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="二分答案" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
      <category term="拓扑排序" scheme="http://yoursite.com/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
      <category term="二分" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/06/20/20180620-HelloWorld/"/>
    <id>http://yoursite.com/2018/06/20/20180620-HelloWorld/</id>
    <published>2018-06-19T16:49:00.210Z</published>
    <updated>2018-07-10T11:00:19.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Welcome-欢迎"><a href="#Welcome-欢迎" class="headerlink" title="Welcome! 欢迎"></a>Welcome! 欢迎</h2><p>It’s so nice for you to visit here!<br>欢迎来到我的博客！</p><p>Look around to find something interesting.<br>四处逛逛来发现一些有趣的东西吧～</p><a id="more"></a><h2 id="This-Blog-and-Me-博客和我"><a href="#This-Blog-and-Me-博客和我" class="headerlink" title="This Blog and Me 博客和我"></a>This Blog and Me 博客和我</h2><h3 id="为什么开设这个博客"><a href="#为什么开设这个博客" class="headerlink" title="为什么开设这个博客"></a>为什么开设这个博客</h3><p>一是对学习生活的记录<br>一篇用心的学习笔记想来会迫使我系统地整理新学到的知识，也会督促我完成学习 plan。</p><p>二是分享我的经验<br>哪怕能帮助你节省一点点时间，能助力你一个新的灵感，都会使我非常开心的呐！</p><h3 id="我"><a href="#我" class="headerlink" title="我"></a>我</h3><p>如果对我感兴趣，请到<a href="https://hyp1231.github.io/about/" target="_blank" rel="noopener">这里</a>来 ～( ´▽｀)～</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Welcome-欢迎&quot;&gt;&lt;a href=&quot;#Welcome-欢迎&quot; class=&quot;headerlink&quot; title=&quot;Welcome! 欢迎&quot;&gt;&lt;/a&gt;Welcome! 欢迎&lt;/h2&gt;&lt;p&gt;It’s so nice for you to visit here!&lt;br&gt;欢迎来到我的博客！&lt;/p&gt;
&lt;p&gt;Look around to find something interesting.&lt;br&gt;四处逛逛来发现一些有趣的东西吧～&lt;/p&gt;
    
    </summary>
    
      <category term="日常" scheme="http://yoursite.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
</feed>
